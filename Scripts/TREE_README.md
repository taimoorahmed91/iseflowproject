# Decision Tree Generator - tree.py

## Overview

The `tree.py` script automatically generates a hierarchical decision tree analysis from your ISE authorization policies.

## What It Does

1. **Reads** `processed_data.json` (generated by your data collection scripts)
2. **Analyzes** all authorization rules across all policy sets
3. **Categorizes** rules into:
   - Endpoint attribute-based rules (using rVLAN, NetworkZone, Tenant)
   - Other condition-based rules
4. **Generates** a comprehensive decision tree analysis
5. **Outputs** `decision_tree.json` with complete analysis

## Output Structure

The generated `decision_tree.json` contains:

### 1. Metadata
```json
{
  "metadata": {
    "generated_at": "2026-02-01T00:24:52.254678Z",
    "source_file": "/path/to/processed_data.json",
    "total_rules": 18
  }
}
```

### 2. Summary Statistics
```json
{
  "summary": {
    "total_rules": 18,
    "endpoint_attribute_rules": 4,
    "other_rules": 14,
    "unique_values": {
      "rVLAN": ["Value1", "Value2"],
      "NetworkZone": ["Value1", "Value2"],
      "Tenant": ["Value1", "Value2"]
    }
  }
}
```

### 3. Mermaid Flowchart
Ready-to-render Mermaid syntax for visualizing the decision tree:
- Orange nodes: rVLAN (top level)
- Purple nodes: NetworkZone (second level)
- Green nodes: Tenant (third level)
- Red nodes: Authorization profiles (results)

You can render this in:
- GitHub Markdown files
- Mermaid Live Editor (https://mermaid.live/)
- VS Code with Mermaid extension
- Any Markdown viewer with Mermaid support

### 4. Evaluation Paths
Complete list of all paths through the decision tree:
```json
{
  "paths": [
    {
      "path_id": 1,
      "conditions": {
        "rVLAN": "Value1",
        "NetworkZone": "Value1",
        "Tenant": "Value1"
      },
      "rule_rank": 0,
      "rule_name": "Authorization Rule 1",
      "profile": "PermitAccess",
      "policy_set": "PolicySet1",
      "state": "enabled"
    }
  ]
}
```

### 5. Hierarchical Tree Structure
Nested structure showing the complete decision tree:
```json
{
  "tree_structure": {
    "Value1": {
      "Value1": {
        "Value1": [
          {
            "result": "PermitAccess",
            "rule_rank": 0,
            "rule_name": "Authorization Rule 1",
            "rule_id": "85c935eb-4e05-436c-9916-d64922fc5ae3",
            "policy_set": "PolicySet1"
          }
        ]
      }
    }
  }
}
```

### 6. Other Rules
Documentation of non-endpoint-attribute rules:
```json
{
  "other_rules": [
    {
      "rank": 0,
      "name": "Wireless Block List Default",
      "profile": "Block_Wireless_Access",
      "policy_set": "Default",
      "state": "enabled",
      "conditions": "Radius.NAS-Port-Type equals Wireless - IEEE 802.11 AND IdentityGroup.Name equals Endpoint Identity Groups:Blocked List"
    }
  ]
}
```

## Usage

### Standalone Execution
```bash
cd /Users/taimoorahmed/Desktop/iseflowproject/Scripts
python3 tree.py
```

### Integrated Execution (via parent.py)
The script is now integrated as **Step 11** in `parent.py`:
```bash
cd /Users/taimoorahmed/Desktop/iseflowproject/Scripts
python3 parent.py
```

The execution sequence is:
1. conditions.py
2. downloadable_acl.py
3. authorization_profiles.py
4. authorization_profiles_detail.py
5. allowed_protocols.py
6. allowed_protocols_detail.py
7. policysets.py
8. authentication.py
9. authorization.py
10. process_ise_data.py
11. **tree.py** ← New!

## Output Files

- **Input**: `/configs/processed_data.json`
- **Output**: `/configs/decision_tree.json`

## Features

### Intelligent Rule Categorization
- Automatically identifies endpoint attribute-based rules
- Separates rules using rVLAN, NetworkZone, and Tenant
- Documents all other rule types separately

### Hierarchical Analysis
- Builds tree structure following: rVLAN → NetworkZone → Tenant → Result
- Respects rule rank order (ascending)
- Handles "Not Specified" attributes gracefully

### Visual Representation
- Generates color-coded Mermaid flowcharts
- Includes rule names, ranks, and profiles
- Ready for immediate visualization

### Comprehensive Documentation
- Lists all unique attribute values
- Documents every evaluation path
- Formats conditions in human-readable format

## Example Output

When you run the script, you'll see:
```
============================================================
ISE Decision Tree Generator
============================================================

Loading data from /path/to/processed_data.json...
Analyzing authorization rules...
  Found 4 endpoint attribute-based rules
  Found 14 other rules
Building hierarchical tree structure...
Building evaluation paths...
Generating Mermaid flowchart...
Formatting other rules...

Saving decision tree to /path/to/decision_tree.json...

============================================================
Decision Tree Generation Complete!
============================================================

Output file: /path/to/decision_tree.json
Total rules analyzed: 18
  - Endpoint attribute rules: 4
  - Other rules: 14

Unique attribute values:
  - rVLAN: 2 values
  - NetworkZone: 2 values
  - Tenant: 2 values
```

## Use Cases

1. **Policy Visualization**: Render the Mermaid flowchart to see your entire policy structure
2. **Documentation**: Use the generated JSON for automated documentation
3. **Analysis**: Understand which attributes are most commonly used
4. **Troubleshooting**: Trace specific evaluation paths through the tree
5. **Auditing**: Review all authorization profiles and their conditions

## Requirements

- Python 3.6+
- Input file: `processed_data.json` (generated by prior scripts)
- No external dependencies required

## Error Handling

The script includes:
- Input file existence checking
- Graceful handling of missing attributes
- Clear error messages with stack traces
- Exit codes (0 = success, 1 = failure)

## Integration with Parent Script

The script has been added to `parent.py` as the final step (Step 11). It will:
- Run automatically after `process_ise_data.py` completes
- Use the freshly generated `processed_data.json`
- Create `decision_tree.json` for immediate use
- Report success/failure through the parent script's error handling

If `tree.py` fails, `parent.py` will:
- Display the error
- Ask if you want to continue (though it's the last script)
- Include it in the execution summary

## Next Steps

After generating `decision_tree.json`, you can:
1. Copy the Mermaid flowchart to visualize your policies
2. Use the JSON data for custom reporting
3. Build UI dashboards using the structured data
4. Automate policy analysis and monitoring
