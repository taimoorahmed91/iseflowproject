# Dynamic Decision Tree Generator - dynamic_tree.py

## Overview

The `dynamic_tree.py` script is an advanced decision tree analyzer that **dynamically discovers** ALL attributes used in your ISE authorization policies and generates **separate decision trees for each policy set**.

Unlike `tree.py` (which focuses on a fixed hierarchy of rVLAN → NetworkZone → Tenant), `dynamic_tree.py` automatically adapts to whatever attributes are present in your configuration.

## Key Features

### 1. **Dynamic Attribute Discovery**
- Scans ALL authorization rules across ALL policy sets
- Recursively extracts attributes from complex condition trees
- Handles AND blocks, OR blocks, nested conditions
- **NO hardcoded attributes** - discovers them from your actual data

### 2. **Per-Policy-Set Analysis**
- Each policy set gets its own complete analysis
- Separate decision trees per policy set
- Separate Mermaid flowcharts per policy set
- Separate summary statistics per policy set

### 3. **Flexible Hierarchies**
- Automatically determines the best attribute hierarchy
- Uses frequency-based ordering (most common attributes first)
- Adapts to different attributes in different policy sets
- Supports arbitrary depth (configurable max levels)

### 4. **Comprehensive Output**
- Global attribute discovery (all attributes across all policy sets)
- Per-policy-set decision trees
- Evaluation paths for each policy set
- Human-readable condition formatting
- Ready-to-render Mermaid flowcharts

## What It Does

### Step 1: Load Data
Reads `processed_data.json` (generated by your data collection pipeline)

### Step 2: Dynamic Attribute Discovery
Recursively scans all conditions to discover:
- Attribute names (e.g., `EndPoints.rVLAN`, `Network Access.AuthenticationStatus`)
- Attribute values (e.g., `Value1`, `AuthenticationPassed`)
- Attribute frequencies (how many rules use each attribute)

### Step 3: Group by Policy Set
Organizes rules by their parent policy set:
- PolicySet1
- PolicySet2
- Default

### Step 4: Determine Hierarchy
For each policy set:
- Identifies which attributes are most commonly used
- Builds a hierarchy based on frequency
- Default: Top 3 most common attributes

### Step 5: Build Decision Trees
Creates hierarchical tree structures for each policy set based on discovered attributes

### Step 6: Generate Visualizations
Produces color-coded Mermaid flowcharts for each policy set

### Step 7: Export Results
Saves comprehensive analysis to `dynamic_decision_tree.json`

## Output Structure

### 1. Metadata
```json
{
  "metadata": {
    "generated_at": "2026-02-01T00:47:32.301790Z",
    "source_file": "/path/to/processed_data.json",
    "total_policy_sets": 3,
    "total_rules": 18
  }
}
```

### 2. Discovered Attributes (Global)
```json
{
  "discovered_attributes": {
    "all_attributes": [
      "EndPoints.Tenant",
      "EndPoints.NetworkZone",
      "EndPoints.rVLAN",
      "Network Access.AuthenticationStatus",
      "Session.PostureStatus",
      "Normalised Radius.RadiusFlowType",
      "IdentityGroup.Name",
      "Network Access.EapAuthentication",
      "Radius.NAS-Port-Type",
      "EndPoints.LogicalProfile",
      "CERTIFICATE.Subject Alternative Name",
      "EndPoints.BYODRegistration",
      "Network Access.UseCase"
    ],
    "attribute_frequency": {
      "EndPoints.Tenant": 4,
      "Network Access.AuthenticationStatus": 4,
      "Normalised Radius.RadiusFlowType": 4,
      "EndPoints.NetworkZone": 3,
      "EndPoints.rVLAN": 3,
      "Session.PostureStatus": 3,
      "IdentityGroup.Name": 2,
      "Network Access.EapAuthentication": 2,
      "Radius.NAS-Port-Type": 1,
      "EndPoints.LogicalProfile": 1,
      "CERTIFICATE.Subject Alternative Name": 1,
      "EndPoints.BYODRegistration": 1,
      "Network Access.UseCase": 1
    },
    "attribute_values": {
      "EndPoints.Tenant": ["Value1", "Value2"],
      "EndPoints.NetworkZone": ["Value1", "Value2"],
      "EndPoints.rVLAN": ["Value1", "Value2"],
      "Network Access.AuthenticationStatus": ["AuthenticationPassed"],
      "Session.PostureStatus": ["Compliant", "NonCompliant", "Unknown"]
    }
  }
}
```

### 3. Policy Set Analysis (Per Policy Set)

Each policy set contains:

#### Summary
```json
{
  "PolicySet1": {
    "summary": {
      "total_rules": 5,
      "hierarchy": [
        "EndPoints.Tenant",
        "EndPoints.NetworkZone",
        "EndPoints.rVLAN"
      ],
      "attributes_used": [
        "EndPoints.Tenant",
        "EndPoints.NetworkZone",
        "EndPoints.rVLAN"
      ],
      "attribute_frequency": {
        "EndPoints.Tenant": 4,
        "EndPoints.NetworkZone": 3,
        "EndPoints.rVLAN": 3
      },
      "unique_values_per_attribute": {
        "EndPoints.Tenant": ["Value1", "Value2"],
        "EndPoints.NetworkZone": ["Value1", "Value2"],
        "EndPoints.rVLAN": ["Value1", "Value2"]
      }
    }
  }
}
```

#### Mermaid Flowchart
Color-coded decision tree visualization specific to the policy set

#### Tree Structure
Hierarchical nested structure showing evaluation paths

#### Paths
List of all evaluation paths with conditions and results:
```json
{
  "paths": [
    {
      "path_id": 1,
      "rule_rank": 0,
      "rule_name": "Authorization Rule 1",
      "rule_id": "85c935eb-4e05-436c-9916-d64922fc5ae3",
      "profile": "PermitAccess",
      "state": "enabled",
      "default": false,
      "conditions": {
        "EndPoints.Tenant": "Value1",
        "EndPoints.NetworkZone": "Value1",
        "EndPoints.rVLAN": "Value1"
      },
      "all_attributes": {
        "EndPoints.Tenant": "Value1",
        "EndPoints.NetworkZone": "Value1",
        "EndPoints.rVLAN": "Value1"
      }
    }
  ]
}
```

#### Rules
Detailed list of all rules in the policy set:
```json
{
  "rules": [
    {
      "rank": 0,
      "name": "Wireless Block List Default",
      "profile": "Block_Wireless_Access",
      "state": "enabled",
      "default": false,
      "attributes": {
        "IdentityGroup.Name": "Endpoint Identity Groups:Blocked List",
        "Radius.NAS-Port-Type": "Wireless - IEEE 802.11"
      },
      "conditions_formatted": "Radius.NAS-Port-Type equals Wireless - IEEE 802.11 AND IdentityGroup.Name equals Endpoint Identity Groups:Blocked List"
    }
  ]
}
```

### 4. Global Summary
```json
{
  "global_summary": {
    "policy_sets_analyzed": 3,
    "total_unique_attributes": 13,
    "most_common_attributes": [
      "EndPoints.Tenant",
      "Network Access.AuthenticationStatus",
      "Normalised Radius.RadiusFlowType",
      "EndPoints.NetworkZone",
      "EndPoints.rVLAN"
    ]
  }
}
```

## Example: Different Policy Sets, Different Attributes

### PolicySet1 (Endpoint-Based)
**Hierarchy:** Tenant → NetworkZone → rVLAN
- Uses endpoint location attributes
- Decision tree based on where devices are located
- Typical for network segmentation policies

### Default Policy Set (Authentication-Based)
**Hierarchy:** AuthenticationStatus → RadiusFlowType → PostureStatus
- Uses authentication and compliance attributes
- Decision tree based on how users authenticate
- Typical for security posture policies

This demonstrates the power of **dynamic discovery** - the script automatically adapts to different policy types!

## Usage

### Standalone Execution
```bash
cd /Users/taimoorahmed/Desktop/iseflowproject/Scripts
python3 dynamic_tree.py
```

### Integrated Execution (via parent.py)
The script is now integrated as **Step 12** in `parent.py`:
```bash
cd /Users/taimoorahmed/Desktop/iseflowproject/Scripts
python3 parent.py
```

Execution sequence:
1. conditions.py
2. downloadable_acl.py
3. authorization_profiles.py
4. authorization_profiles_detail.py
5. allowed_protocols.py
6. allowed_protocols_detail.py
7. policysets.py
8. authentication.py
9. authorization.py
10. process_ise_data.py
11. tree.py
12. **dynamic_tree.py** ← New!

## Output Files

- **Input**: `/configs/processed_data.json`
- **Output**: `/configs/dynamic_decision_tree.json`

## Comparison: tree.py vs dynamic_tree.py

| Feature | tree.py | dynamic_tree.py |
|---------|---------|-----------------|
| Attribute discovery | Hardcoded (rVLAN, NetworkZone, Tenant) | Dynamic (discovers all attributes) |
| Hierarchy | Fixed: rVLAN → NetworkZone → Tenant | Flexible: Based on frequency |
| Analysis scope | Global (all rules together) | Per-policy-set (separate analyses) |
| Adaptability | Works for specific use case | Works for ANY ISE configuration |
| Flowcharts | Single global flowchart | Separate flowchart per policy set |
| Best for | Simple endpoint segmentation | Complex, multi-policy environments |

## When to Use Each Script

### Use `tree.py` when:
- You specifically want rVLAN → NetworkZone → Tenant hierarchy
- You want a single global view
- You have a simple configuration focused on endpoint attributes

### Use `dynamic_tree.py` when:
- You want to see what attributes are actually being used
- You have multiple policy sets with different purposes
- You need per-policy-set analysis
- You want the script to adapt to your configuration automatically
- You have complex authorization policies using various attributes

## Advanced Features

### Recursive Condition Parsing
The script handles complex nested conditions:
```json
{
  "conditionType": "ConditionAndBlock",
  "children": [
    {
      "conditionType": "ConditionOrBlock",
      "children": [
        { "conditionType": "ConditionAttributes", ... },
        { "conditionType": "ConditionAttributes", ... }
      ]
    },
    { "conditionType": "ConditionAttributes", ... }
  ]
}
```

### Attribute Frequency Analysis
Determines which attributes are most important in your configuration:
```
Most common attributes:
  EndPoints.Tenant: 4 rules
  Network Access.AuthenticationStatus: 4 rules
  Normalised Radius.RadiusFlowType: 4 rules
  EndPoints.NetworkZone: 3 rules
  EndPoints.rVLAN: 3 rules
```

### Automatic Hierarchy Determination
For each policy set, builds a hierarchy based on:
1. **Frequency**: Most common attributes appear higher in tree
2. **Max levels**: Default 3 levels (configurable in code)
3. **Relevance**: Only uses attributes actually present in that policy set

## Use Cases

### 1. Configuration Audit
Discover which attributes are being used and how frequently

### 2. Policy Set Comparison
Compare different policy sets side-by-side to see their different approaches

### 3. Migration Planning
Understand existing configuration before migrating to new ISE deployment

### 4. Documentation
Auto-generate comprehensive policy documentation

### 5. Troubleshooting
Trace evaluation paths to understand why a device got a certain authorization profile

### 6. Optimization
Identify redundant or overlapping rules across policy sets

### 7. Training
Visualize policy logic for training new administrators

## Requirements

- Python 3.6+
- Input file: `processed_data.json`
- No external dependencies

## Error Handling

- Input file existence checking
- Graceful handling of missing/null conditions
- Handles default rules (with no conditions)
- Clear error messages with stack traces
- Exit codes (0 = success, 1 = failure)

## Sample Console Output

```
============================================================
ISE Dynamic Decision Tree Generator
============================================================

Loading data from /path/to/processed_data.json...
Discovering attributes from authorization policies...
  Discovered 13 unique attributes
  Analyzed 3 policy sets

Global attribute discovery:
  EndPoints.Tenant: 4 rules
  Network Access.AuthenticationStatus: 4 rules
  Normalised Radius.RadiusFlowType: 4 rules
  EndPoints.NetworkZone: 3 rules
  EndPoints.rVLAN: 3 rules
  Session.PostureStatus: 3 rules
  IdentityGroup.Name: 2 rules
  Network Access.EapAuthentication: 2 rules
  Radius.NAS-Port-Type: 1 rules
  EndPoints.LogicalProfile: 1 rules

============================================================
Per-Policy-Set Analysis
============================================================

Analyzing policy set: PolicySet1
  Building tree for PolicySet1 with hierarchy: ['EndPoints.Tenant', 'EndPoints.NetworkZone', 'EndPoints.rVLAN']
  Generating Mermaid flowchart for PolicySet1

Analyzing policy set: Default
  Building tree for Default with hierarchy: ['Network Access.AuthenticationStatus', 'Normalised Radius.RadiusFlowType', 'Session.PostureStatus']
  Generating Mermaid flowchart for Default


Saving dynamic decision tree to /path/to/dynamic_decision_tree.json...

============================================================
Dynamic Tree Generation Complete!
============================================================

Output file: /path/to/dynamic_decision_tree.json
Policy sets analyzed: 3
Total attributes discovered: 13
Total rules analyzed: 18

Most common attributes:
  EndPoints.Tenant: 4 rules
  Network Access.AuthenticationStatus: 4 rules
  Normalised Radius.RadiusFlowType: 4 rules
  EndPoints.NetworkZone: 3 rules
  EndPoints.rVLAN: 3 rules
```

## Integration with Parent Script

The script has been added to `parent.py` as Step 12 (after `tree.py`). It will:
- Run automatically after `tree.py` completes
- Use the same `processed_data.json` input
- Generate `dynamic_decision_tree.json` for advanced analysis
- Report success/failure through parent script's error handling

## Future Enhancements

Potential improvements for future versions:
1. Configurable hierarchy (allow user to specify attribute order)
2. Support for OR conditions in tree structure (multiple paths)
3. Graph visualization (NetworkX, Graphviz)
4. Rule conflict detection
5. Coverage analysis (which rules are never matched)
6. Policy recommendations based on discovered patterns

## Troubleshooting

### No Hierarchical Attributes Found
If you see "No hierarchical attributes found for [PolicySet]", it means:
- The policy set only has default rules (no conditions)
- OR all rules have no conditions
- This is normal for some policy sets

### Attribute Not Appearing
If an expected attribute doesn't appear:
- Check that rules actually use that attribute in conditions
- Verify the attribute is spelled correctly in ISE
- Ensure the attribute is in a ConditionAttributes block (not just a reference)

## Summary

`dynamic_tree.py` is a powerful tool for understanding your ISE authorization policies. It automatically discovers all attributes, analyzes each policy set independently, and generates comprehensive documentation and visualizations - all without hardcoding any attribute names or hierarchies.

Perfect for complex, multi-policy ISE deployments where different policy sets serve different purposes!
